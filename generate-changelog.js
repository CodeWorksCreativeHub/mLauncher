#!/usr/bin/env node

const { execSync } = require("child_process");
const fs = require("fs");

const OUTPUT_FILE = "CHANGELOG.md";
const TAGS_TO_INCLUDE = 10; // Number of recent tags to include
const REPO_URL = "https://github.com/DroidWorksStudio/mLauncher";

const HEADER = `# Changelog

All notable changes to this project will be documented in this file. See [conventional commits](https://www.conventionalcommits.org/) for commit guidelines.\n\n`;

const FOOTER = `---
> Generated by DroidWorksStudio`;

// Verbose logging
const VERBOSE = process.argv.includes("--verbose");
function log(...args) {
	if (!VERBOSE) return;

	const cleanArgs = args.map((arg) => {
		if (typeof arg === "string") {
			return arg.replace("### ", "").trim();
		}
		return arg;
	});

	console.log(...cleanArgs);
}

// Commit parsing rules
const commitParsers = [
	// skip some "noise" commits
	{ message: /^chore\(release\): prepare for/i, skip: true },
	{ message: /^chore\(deps.*\)/i, skip: true },
	{ message: /^chore\(change.*\)/i, skip: true },
	{ message: /^chore\(pr\)/i, skip: true },
	{ message: /^chore\(pull\)/i, skip: true },
	{ message: /^fixes/i, skip: true },

	// Enhancements (new features, improvements, UX, performance, refactors)
	{ message: /^feat|^perf|^refactor|^style|^ui|^ux/i, group: "### Enhancements:" },

	// Bug fixes & hotfixes
	{ message: /^fix|^bug|^hotfix|^emergency/i, group: "### Bug Fixes:" },

	// Documentation & language/i18n
	{ message: /^doc|^lang|^i18n/i, group: "### Documentation & Language:" },

	// Security
	{ message: /^security/i, group: "### Security:" },

	// Reverts
	{ message: /^revert/i, group: "### Reverts:" },

	// Build, dependencies, configuration, CI/CD, versioning, release
	{ message: /^build|^dependency|^deps|^config|^configuration|^ci|^pipeline|^release|^version|^versioning/i,
	  group: "### Build, Dependencies & Meta:" },

	// Tests
	{ message: /^test/i, group: "### Tests:" },

	// Infrastructure & Ops
	{ message: /^infra|^infrastructure|^ops/i, group: "### Infrastructure & Ops:" },

	// Chore & cleanup
	{ message: /^chore|^housekeeping|^cleanup|^clean\(up\)/i, group: "### Maintenance & Cleanup:" },

	// Feature removal / drops
	{ message: /^drop|^remove/i, group: "### Feature Removals:" },
];

// Build group order directly from commitParsers
const GROUP_ORDER = commitParsers
    .filter((p) => !p.skip)
    .map((p) => p.group);


// Helper functions
function run(cmd) {
	log("Running:", cmd);
	return execSync(cmd, { encoding: "utf8" }).trim();
}

function formatDate(dateString) {
	const date = new Date(dateString);
	const day = String(date.getDate()).padStart(2, "0");
	const month = date.toLocaleString("en-US", { month: "long" });
	const year = date.getFullYear();
	return `- (${day}, ${month} ${year})`;
}

function classifyCommit(msg) {
	for (const parser of commitParsers) {
		if (parser.message.test(msg)) {
			if (parser.skip) return null;
			return { group: parser.group, message: msg };
		}
	}
	return null; // Skip commits that don't match
}

function cleanMessage(message) {
	// Remove conventional commit type (feat, fix, etc.), with optional scope (...) and colon
	return message.replace(
		/^(feat|fix|bug|lang|i18n|doc|perf|refactor|style|ui|ux|security|revert|release|dependency|deps|build|ci|pipeline|chore|housekeeping|version|versioning|config|configuration|cleanup|clean\(up\)|drop|remove|hotfix|emergency|test|infra|infrastructure|ops|asset|content|exp|experiment|prototype)\s*(\(.+?\))?:\s*/i,
		""
	);
}

function linkPR(message) {
	// Replace (#123) with a link to the PR
	return message.replace(/\(#(\d+)\)/g, (_, num) => `([#${num}](${REPO_URL}/pull/${num}))`);
}

// Get last N tags
const allTags = run("git tag --sort=-creatordate").split("\n");
const tags = allTags.slice(0, TAGS_TO_INCLUDE);
log("Tags to include:", tags);

let changelog = HEADER;

// "Coming Soon" section for commits after latest tag
const latestTag = tags[0] || "";
log("Latest tag:", latestTag);

if (latestTag) {
	const rawUnreleased = run(`git log ${latestTag}..HEAD --pretty=format:"%h|%s"`).split("\n");

	const unreleasedCommits = rawUnreleased
		.map((line) => {
			const [hash, ...msgParts] = line.split("|");
			const message = msgParts.join("|");
			const classified = classifyCommit(message);
			if (!classified) return null;
			return { ...classified, hash };
		})
		.filter(Boolean);

	if (unreleasedCommits.length > 0) {
		log("Unreleased commits found:", unreleasedCommits.length);
		changelog += "## [Coming Soon](https://github.com/DroidWorksStudio/mLauncher/tree/main) - TBD\n\n";
		const groups = {};
		for (const c of unreleasedCommits) {
			groups[c.group] = groups[c.group] || [];
			groups[c.group].push(`* ${linkPR(cleanMessage(c.message))} ([${c.hash}](${REPO_URL}/commit/${c.hash}))`);
		}
		for (const group of GROUP_ORDER) {
			if (groups[group]) {
				log(`Unreleased group: ${group}, commits: ${groups[group].length}`);
				changelog += `${group}\n\n${groups[group].join("\n")}\n\n`;
			}
		}
	}
}

// Generate changelog for each tag
for (let i = 0; i < tags.length; i++) {
	const currentTag = tags[i];

	// Determine range
	let range;
	if (i === tags.length - 1) {
		// Oldest tag
		const oldestTagIndex = allTags.indexOf(currentTag);
		const parentTag = allTags[oldestTagIndex - 1];
		range = parentTag ? `${parentTag}..${currentTag}` : currentTag;
	} else {
		const previousTagInSlice = tags[i + 1];
		range = `${previousTagInSlice}..${currentTag}`;
	}

	log(`Processing tag: ${currentTag}, range: ${range}`);

	// Commits
	const rawCommits = run(`git log ${range} --pretty=format:"%h|%s"`).split("\n");
	const commits = rawCommits
		.map((line) => {
			const [hash, ...msgParts] = line.split("|");
			const message = msgParts.join("|");
			const classified = classifyCommit(message);
			if (!classified) return null;
			return { ...classified, hash };
		})
		.filter(Boolean);

	log(`Commits found for ${currentTag}:`, commits.length);
	if (commits.length === 0) continue;

	// Tag date
	const tagDateRaw = run(`git log -1 --format=%ad --date=short ${currentTag}`);
	const tagDateFormatted = formatDate(tagDateRaw);

	changelog += `## [${currentTag}](${REPO_URL}/tree/${currentTag}) ${tagDateFormatted}\n\n`;

	const groups = {};
	for (const c of commits) {
		groups[c.group] = groups[c.group] || [];
		groups[c.group].push(`* ${linkPR(cleanMessage(c.message))} ([${c.hash}](${REPO_URL}/commit/${c.hash}))`);
	}

	for (const group of GROUP_ORDER) {
		if (groups[group]) {
			log(`Group: ${group}, commits: ${groups[group].length}`);
			changelog += `${group}\n\n${groups[group].join("\n")}\n\n`;
		}
	}
}

// Append footer
changelog += FOOTER;

// Write file
fs.writeFileSync(OUTPUT_FILE, changelog, "utf8");
console.log(`âœ… Generated ${OUTPUT_FILE}`);
