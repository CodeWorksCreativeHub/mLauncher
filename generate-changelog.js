#!/usr/bin/env node

const { execSync } = require("child_process");
const fs = require("fs");

const OUTPUT_FILE = "CHANGELOG.md";
const TAGS_TO_INCLUDE = 5;
const REPO_URL = "https://github.com/DroidWorksStudio/mLauncher";
const HEADER = `# Changelog

All notable changes to this project will be documented in this file. See [conventional commits](https://www.conventionalcommits.org/) for commit guidelines.

`; // Your custom header

const FOOTER = `
---
> Generated by DroidWorksStudio
`;

// Commit parsing rules
const commitParsers = [
	{ message: /^chore\(release\): prepare for/i, skip: true },
	{ message: /^chore\(deps.*\)/i, skip: true },
	{ message: /^chore\(change.*\)/i, skip: true },
	{ message: /^chore\(pr\)/i, skip: true },
	{ message: /^chore\(pull\)/i, skip: true },
	{ message: /^fixes/i, skip: true },
	{ message: /^feat/i, group: "### Implemented Enhancements:" },
	{ message: /^fix|^bug/i, group: "### Bug Fixes:" },
	{ message: /^lang/i, group: "### Language Support:" },
	{ message: /^doc/i, group: "### Documentation:" },
	{ message: /^perf/i, group: "### Performance Improvements:" },
	{ message: /^refactor/i, group: "### Refactoring:" },
	{ message: /^style/i, group: "### Styling Changes:" },
	{ message: /^security/i, group: "### Security Updates:" },
	{ message: /^revert/i, group: "### Reverts:" },
	{ message: /^release/i, group: "### Releases:" },
	{ message: /^dependency|^deps/i, group: "### Dependency Updates:" },
	{ message: /^ci|^pipeline/i, group: "### Continuous Integration (CI):" },
	{ message: /^chore|^housekeeping/i, group: "### Chore:" },
	{ message: /^version|^versioning/i, group: "### Versioning:" },
	{ message: /^config|^configuration/i, group: "### Configuration Changes:" },
	{ message: /^cleanup|^clean\(up\)/i, group: "### Code Cleanup:" },
	{ message: /^drop|^remove/i, group: "### Feature Removal:" },
	{ message: /^hotfix|^emergency/i, group: "### Hotfixes:" },
];

// Helper functions
function run(cmd) {
	return execSync(cmd, { encoding: "utf8" }).trim();
}

function formatDate(dateString) {
	const date = new Date(dateString);
	const day = String(date.getDate()).padStart(2, "0");
	const month = date.toLocaleString("en-US", { month: "long" });
	const year = date.getFullYear();
	return `- (${day}, ${month} ${year})`;
}

function classifyCommit(msg) {
	for (const parser of commitParsers) {
		if (parser.message.test(msg)) {
			if (parser.skip) return null;
			return { group: parser.group, message: msg };
		}
	}
	return null; // Skip commits that don't match
}

// Get last N tags
const tags = run(`git tag --sort=-creatordate`).split("\n").slice(0, TAGS_TO_INCLUDE);
let changelog = HEADER;

// "Coming Soon" section for commits after latest tag
const latestTag = tags[0] || "";
if (latestTag) {
	const unreleasedCommits = run(`git log ${latestTag}..HEAD --pretty=format:"%s"`)
		.split("\n")
		.map((c) => classifyCommit(c))
		.filter(Boolean);

	if (unreleasedCommits.length > 0) {
		changelog += "## [Coming Soon](https://github.com/DroidWorksStudio/mLauncher/tree/main) - TBD\n";
		const groups = {};
		for (const c of unreleasedCommits) {
			groups[c.group] = groups[c.group] || [];
			groups[c.group].push(`* ${c.message}`);
		}
		for (const group of Object.keys(groups)) {
			changelog += `${group}\n${groups[group].join("\n")}\n\n`;
		}
	}
}

// Generate changelog for each tag
for (let i = 0; i < tags.length; i++) {
	const currentTag = tags[i];
	// Determine the range
	let range;
	if (i === tags.length - 1) {
		// Oldest tag in the slice, only show commits between it and the previous tag in git history
		const allTags = run("git tag --sort=creatordate").split("\n");
		const oldestTagIndex = allTags.indexOf(currentTag);
		const parentTag = allTags[oldestTagIndex - 1];
		range = parentTag ? `${parentTag}..${currentTag}` : currentTag;
	} else {
		const previousTagInSlice = tags[i + 1];
		range = `${previousTagInSlice}..${currentTag}`;
	}

	// Tag date
	const tagDateRaw = run(`git log -1 --format=%ad --date=short ${currentTag}`);
	const tagDateFormatted = formatDate(tagDateRaw);

	// Commits
	const commits = run(`git log ${range} --pretty=format:"%s"`)
		.split("\n")
		.map((c) => classifyCommit(c))
		.filter(Boolean);

	if (commits.length === 0) continue;

	changelog += `## [${currentTag}](${REPO_URL}/tree/${currentTag}) ${tagDateFormatted}\n`;

	const groups = {};
	for (const c of commits) {
		groups[c.group] = groups[c.group] || [];
		groups[c.group].push(`* ${c.message}`);
	}

	for (const group of Object.keys(groups)) {
		changelog += `${group}\n${groups[group].join("\n")}\n\n`;
	}
}

// Later, after generating the changelog content, append the footer:
changelog += FOOTER;

// Write file
fs.writeFileSync(OUTPUT_FILE, changelog, "utf8");
console.log(`âœ… Generated ${OUTPUT_FILE}`);
